---
title: "Woodland-Chaparral Community Analysis"
output: 
  html_document:
    toc: TRUE
    toc_float: TRUE
    toc_depth: 6
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      warning=FALSE, 
                      message=FALSE)
```

## Overview 
**These analyses explore the composition of plant communities where some
woodland and chaparral species often co-occur on the fringes of the Mojave Desert.**

**To discern whether the composition of these assemblages are all pretty much the
same, or characteristically somehow different, I set out to use a k-means clustering analysis.**

**To explore how the distribution of chaparral species varies among communities, I 
generated some elevation maps with chaparral density bubble plots.**

## Libraries
```{r}
#load libraries
library(tidyverse)
library(here)
library(kableExtra)
library(cluster)
library(factoextra)
library(maps)
library(mapdata)
library(mapproj)
library(ggplot2)
library(ggpubr)
library(raster)
library(scales)
library(rgeos)
```

## Data review 
**There are two preliminary datasets:   
                 1) species abundance in transects  
                 2) density of chaparral shrubs in transects**  
      
**The data matrix includes 21 species (given as: *Genus species* = "GenSpe") sampled across 14 transects (T2, T3, etc.).**   

**9 of these species are defined as disjunct, whereas the other 12 listed are included because they were common at sites.**
```{r}
df <- read_csv('C:/Users/pfura/Documents/Microclimatic Refugia of Disjunct Chaparral Relicts in Mountains of the Eastern Mojave Desert/K-means clustering/Data/ChaparralKmeans2.csv')
df %>% kbl() %>% kable_classic()
```

##Prepare data for k-means clustering 
```{r, results = "hide"}


#need to change the variable format of Species to character
df$Species <- as.character(df$Species)
str(df)

#change column variable as row names
rownames(df) <- c(df$Species)
head(df)

#get rid of non-numeric first column
df2 <- df[,-1]
head(df2)

#final preparation
df2 <- na.omit(df2) #removes NAs #I don't have NAs but this is such a formality...
df2 <- scale(df2) #standardize variables (recommended)
head(df2)
```

## Run k-means clustering
**k-means clustering is a non-hierarchical clustering algorithm that uses a matrix of variables and objects to assign the association of each to some number of similarity clusters (k).**

**The Euclidean distance of a matrix can be used to calculate the similarity of species abundance (variables) between transects (objects).** 

**The k-means analysis iteratively assigns the variables to the cluster that minimizes both within and between cluster variance.** 
```{r, fig.align = "center", results = "hide"}
#take a look at the Euclidean distance matrix
distance <- get_dist(df)
fviz_dist(distance, gradient = list(low = "#00AFBB", mid = "white", high = "#FC4E07"))
#red pairs are dissimilar
#teal pairs are similar

#generate the k-means output
k2 <- kmeans(df2, centers = 2, nstart = 25)
str(k2)

#lots of info here
#cluster: A vector of integers (from 1:k) indicating the cluster to which each point is allocated.
#centers: A matrix of cluster centers.
#totss: The total sum of squares.
#withinss: Vector of within-cluster sum of squares, one component per cluster.
#tot.withinss: Total within-cluster sum of squares, i.e. sum(withinss).
#betweenss: The between-cluster sum of squares, i.e. $totss-tot.withinss$.
#size: The number of points in each cluster.
```

## Look for approriate levels of k
**The average silhouette method is a quantitative technique for identifying the number of clusters that maximizes the variance explained by the model**

**Use to non-subjectively specify the appropriate level of k.** 
```{r, fig.align = "center"}
#function to compute average silhouette for k clusters
fviz_nbclust(df2, kmeans, method = "silhouette") #suggests k=2 is best
```

## Final analysis with k = 2
**It pretty much looks like there are two clusters with support from the average silhouette method**
```{r, fig.show = "hide", results = "hide"}
#compute k-means clustering with k = 2
set.seed(123)
final <- kmeans(df2, 2, nstart = 25)
print(final)

#build a ggplot onto the fviz_cluster function
fviz_cluster(final, data = df2, repel = TRUE, ellipse = TRUE,show.clust.cent = FALSE, main = FALSE)+
             scale_colour_manual(values = c("dodger blue","red")) +
             scale_fill_manual(values = c("light blue", "orange"))+
             theme_bw()+
             ggsave("kmeans.png")
```

## Results
```{r}
#generate final output with k = 2
final_output<-df %>% ###must use the non-standardized data here
  mutate(Cluster = final$cluster) %>%
  group_by(Cluster) %>%
  summarise_all("mean")
final_output %>% kbl() %>% kable_classic() #shows the k-means values for each cluster by transect
```

<center>

![](/Users/pfura/Documents/Biol 551L/Chaparral-Community-Analysis/K-means_Analysis/Output/KmeansPlot2.png)

</center>

**The results show two clusters of size n = 6 and n = 15 species respectively.** 

**The n = 6 cluster appears to be defined as an assemblage of species associated with a pine-oak woodland, whereas the n = 15 cluster appears to be defined as an assemblage of species associated with chaparral.** 

**While there were some species that were assigned to the chaparral cluster that seem more characteristic of pine-oak woodland (e.g. *Juniperus osteosperma* and *Pinus edulis*), species assignment overall points to the occurrence of two major plant assemblages found within the sites sampled.** 

## Chaparral density map
**The first map shows the density of chaparral-type plant species and location of sites surveyed in two counties within CA**  

## Map data preparation
```{r, fig.align="center"}
mapdf<-read_csv(here('Chaparral_Density_Maps/Data/ChaparralDensity.csv'))
density<-mapdf 
mapdf %>% kbl() %>% kable_classic
```
```{r}
# get data for counties
counties<-map_data("county")
counties<-as.data.frame(counties)
LASB<-counties %>%
  filter(subregion == c("los angeles", "san bernardino"))
  counties[counties$subregion == "los angeles", "subregion"] <- "Los Angeles"
view(LASB)

#make CA map with chaparral density embedded in
p1<-ggplot()+
  geom_polygon(data = LASB, 
               aes(x = long, 
                   y = lat,
                   group = group,
                  fill = subregion))+
  geom_point(shape=21,data = density, 
             aes(x = long, 
                 y = lat,
                 size = density))+
  theme(panel.background = element_rect(fill = "white"))+
  scale_fill_discrete(labels = c("Los Angeles", "San Bernardino"))+
  coord_map(projection = "sinusoidal")
  ggsave(here("Chaparral_Density_Maps","Output","ChaparralDensity.png"))
```


<center>

![](/Users/pfura/Documents/Biol 551L/Chaparral-Community-Analysis/Chaparral_Density_Maps/Output/ChaparralDensity.png)

<center>

## Raster elevation grids
**The second set of maps uses raster elevation data to look closely at chaparral density and the difference in topography among sites** 

**This requires generating some digital elevation models (DEM's)**

**The DEM's can then go into ggplot and be used to make elevation grids along with
the chaparral denisty data**  
```{r, fig.align = "center"}

#New York Mnts
#make zoomed in graphs w/ raster layer
#get elevation data
dem1<- getData("SRTM",lat=35.2,lon=-115.35)
dem2<- getData("SRTM",lat=35.3,lon=-115.25)
dem <- merge(dem1,dem2)

#create polygon to crop the elevation data file   
Ps1 = as(extent(35.2, 35.3, -115.35, -115.25), 'SpatialPolygons')
crs(Ps1) = "+proj=longlat +datum=WGS84 +no_defs"

#lower the resolution to enable faster plotting
dem_lower_res <- aggregate(dem, fact=10)
dem.p  <-  rasterToPoints(dem_lower_res)
df2 <-  data.frame(dem.p)
colnames(df2) = c("lon", "lat", "alt")

#make ggplot
p2<-ggplot(df2) +
  geom_raster(aes(lon, lat, fill = alt))+
  scale_fill_gradientn(colours = terrain.colors(10))+
  geom_polygon(data= LASB, aes(x=long, y=lat), color= 'blue', fill= NA) +            
  coord_sf(xlim = c(-115.35, -115.25), ylim = c(35.2, 35.3))+
  geom_point(shape=21,data = density, 
             aes(x = long, 
                 y = lat,
                 size = density))+
  theme_bw()+
  theme(axis.text.x = element_text(size=6), axis.text.y = element_text(size=6))

#San Bernardino Mnts
#make zoomed in graphs w/ raster layer
#get elevation data
dem1<- getData("SRTM",lat=34.25,lon=-117.25)
dem2<- getData("SRTM",lat=35.35,lon=-117.15)
dem <- merge(dem1,dem2)
  
#create polygon to crop the elevation data file   
 Ps1 = as(extent(34.25, 34.35, -117.25, -117.15), 'SpatialPolygons')
crs(Ps1) = "+proj=longlat +datum=WGS84 +no_defs"

#lower the resolution to enable faster plotting
dem_lower_res <- aggregate(dem, fact=10)
dem.p  <-  rasterToPoints(dem_lower_res)
df2 <-  data.frame(dem.p)
colnames(df2) = c("lon", "lat", "alt")

#make ggplot  
p3<-ggplot(df2) +
  geom_raster(aes(lon, lat, fill = alt))+
  scale_fill_gradientn(colours = terrain.colors(10))+
  geom_polygon(data= LASB, aes(x=long, y=lat), color= 'blue', fill= NA) +            
  coord_sf(xlim = c(-117.25, -117.15), ylim = c(34.25, 34.35))+
  geom_point(shape=21,data = density, 
             aes(x = long, 
                 y = lat,
                 size = density))+
  theme_bw()+
  theme(axis.text.x = element_text(size=6), axis.text.y = element_text(size=6))

#San Gabriel Mnts
#make zoomed in graphs w/ raster layer
#get elevation data
dem1<- getData("SRTM",lat=34.35,lon=-117.85)
dem2<- getData("SRTM",lat=34.45,lon=-117.75)
dem <- merge(dem1,dem2)

#create polygon to crop the elevation data file   
Ps1 = as(extent(34.35, 34.45, -117.85, -117.75), 'SpatialPolygons')
crs(Ps1) = "+proj=longlat +datum=WGS84 +no_defs"

#lower the resolution to enable faster plotting
dem_lower_res <- aggregate(dem, fact=10)
dem.p  <-  rasterToPoints(dem_lower_res)
df2 <-  data.frame(dem.p)
colnames(df2) = c("lon", "lat", "alt")

#make ggplot
p4<-ggplot(df2) +
  geom_raster(aes(lon, lat, fill = alt))+
  scale_fill_gradientn(colours = terrain.colors(10))+
  geom_polygon(data= LASB, aes(x=long, y=lat), color= 'blue', fill= NA) +            
  coord_sf(xlim = c(-117.85, -117.75), ylim = c(34.35, 34.45))+
  geom_point(shape=21,data = density, 
             aes(x = long, 
                 y = lat,
                 size = density))+
  theme_bw()+
  theme(axis.text.x = element_text(size=6), axis.text.y = element_text(size=6))

#combine all 3 grids together into a single figure
ggarrange(p4, p3, p2,
          ncol = 3, nrow = 1,
          common.legend = TRUE)
          
```

